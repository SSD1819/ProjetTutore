---
title: "Projet Cogmont"
author: "Azat, Lucas, Matthieu, Etienne"
date: "March 13, 2019"
output:
  pdf_document:
    toc: true
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction

# Contexte / Sujet
Ce projet nous à été proposé par l'Institut des sciences cognitives - Marc Jeannerod spécialisé dans la neuroscience. L’UMR 5304 créée en 2007 est un des deux laboratoires de l’Institut des Sciences Cognitives – Marc Jeannerod. L'UMR 5304 est un laboratoire interdisciplinaire qui intègre l'expertise de chercheur des Sciences de la Vie (psychologie cognitive, neurosciences) et de médecine (pédo-psychiatrie, neuro-pédiatrie) avec celle de chercheur des Sciences Humaines et Sociales (linguistique computationelle et théorique et philosophie) pour étudier la nature et la spécificité de l'esprit humain.

## Les besoins d'un changement éducatif

 Le député et mathématicien Cédric Villani a publié un rapport pour renforcer l'apprentissage des mathématiques à l'école. Les élèves français sont aujourd'hui plus que médiocres dans cette discipline. Pourtant, jusqu'en 1985, l'enseignement des maths en France était reconnu comme l'un des meilleurs. Or, en décembre 2016, dernière édition de classement Pisa (Programme for international student assessment) la France a fini 24ème sur 72, en recule par rapport à la dernière édition. Pour mettre un terme à cette tendance inquiétante de la dégradation du niveau des élèves français en mathématiques, le gouvernement est à la recherche de nouvel pédagogie d'enseignement des mathématiques.

## Les pedagogies

\begin{description}
	\item[Pédagogie Montessori:] 

La pédagogie Montessori est une méthode d'éducation créée en 1907 par Maria Montessori.\newline
	La pédagogie se base sur trois principe:\newline
	-l’autodiscipline: les enfants sont libres de choisir l’activité qu’ils souhaitent faire parmi celles qui leur sont proposées.\newline
	-L’action en périphérique: Selon Maria Montessori, il est plus profitable d’agir sur son environnement plutôt que sur l’enfant lui-même (comme des classes multi-âge).

\item[Pédagogie "Traditionnelle":]

La pédagogie traditionnelle est celle du modèle transmissif. Selon le triangle pédagogique de Jean Houssaye, cette pédagogie privilégie la relation entre l'enseignant et le savoir. Autrement dit, l'enseignant expose un savoir sous forme de cours magistral, généralement suivi d'exercices ou/et de leçons à apprendre. L'élève doit intégrer et appliquer le savoir exposé par l'enseignant.


\end{description}

# Méthodologie
<!-- On parle au passé ? "nous avons vu ..." ou au futur ? "par la suite nous verrons ..."  -->
Afin de répondre au mieux à notre problématique nous avons fait le choix d'utiliser plusieurs méthodes statistiques différentes pour analyser nos données. Pour cela nous avons dans un premier temps utilisé une méthode qui permet de résumer l'information globale du jeu de données : l'analyse factorielle, et la classification ascendante hiérarchique (pour faire des regroupement de variables). Puis dans un but prédictif nous avons utilisé la regression logistique et les arbres de regressions. Plusieurs tests ont été fait en parallèles, comme celui du chi2, de student.. 

## Analyse factorielle

La méthode d'analyse factorielle que nous avons utilisé ici est l'analyse des correspondances multiples (ACM), qui est une méthode de synthétisations du nombre de dimensions pour les données qualitative. Cela nous permet d'appréhender plus rapidement le jeu de donnée, et avoir une première idée de ce qui diffèrent les individus entre eux (ou ce qui les rapproche).
L'ACM permet dans un nuage à N dimension, en cherchant les plans orthogonaux qui maximisent la variance entre les individus, à résumer celles ci en 4 voir 5 dimensions. 
l'ACM a été réalisée sur les réponses aux questions en variables actives (celles qui définissent le placement des individus sur le graphe) avec les variables portant sur la pédagogie, la question 1, et l'âge en illustratives (ajoutée après le placement des individus sur le graphe).

## Regression Logistique

Notre problématique étant de voir s'il existe un lien entre la façon d'enseigner et les réponses au test, nous avons voulu essayer de prédire la méthode d'enseignement à l'aide des réponses des élèves avec la regression logistique. Cette méthode permet de modéliser une classification, à l'aide notamment de l'odds ratio <!-- partie à verifier --> 

## Classification Ascendante Hiérachique

N'ayant aucune information au préalable sur le thème des questions, leur regroupement...etc Mais sachant que certaines questions faisaient appellent aux mêmes compétences. Nous avons utilisé une variante de la classification ascendante hiérarchique (CAH) afin de partitionner nos variables.

## Arbre de regression 

L'arbre de régression est une technique d'apprentissage supervisé, qui permet en analysant un grand nombre de données, de prédire une variable à expliquer. Ils sont beaucoup utilisés dans le domaine du marketing, et plus récemment dans le domaine du machine learning (apprentissage automatique).
Dans un premier temps il s'agit d'exprimer la variable à expliquer en fonction d'un maximum de variables explicative, puis d'élaguer l'arbre afin de minimiser l'erreur, soit l'écart entre la valeur prédite et la valeur réelle. Cela revient donc à faire une régression logistique sur les données, puis d'appliquer l'algorithme de construction d'arbre à partir des résultats.

# Traitement des données
## Présentation des données de départ
\section{Importation des données}
Notre jeu de données est composé de trois fichiers Excel (.xlsx), avec les résultats de chaque promotion au test cognitif européen.
    \begin{description}
    \item[MathsJetons\_2015-2016.xlsx :] Pour l'année 2015/2016.
    \item[MathsJetons\_2015-2016.xlsx :] Pour l'année 2016/2017.
    \item[MathsJetons\_2016-2017.xlsx :] Pour l'année 2017/2018.
    \end{description}
    Chaque jeu de données représente les résultats questions par questions (en comptant les sous-questions) des élèves  ainsi que leurs catégories pédagogiques et des informations telles que l'encadrant, le niveau scolaire, la langue natale, l'âge, le type de classe (mélangé entre plusieurs section ou pas), l'année de passage du test et leur école.
    Il y à 10 questions divisées en sous questions, ce qui fait un total de 34 réponses. Chaque question est indépendante et pour répondre à la sous question suivante il faut une bonne réponse à la sous-question précédente, sauf pour la question 4, toutes ses sous-questions sont indépendantes. Une bonne réponse correspond à un 1 et une mauvaise réponse à un 0, sauf pour la réponse à la question 1 qui est la valeur de comptage maximale de l'enfant.
    Ici les élèves viennent tous de l'école Ambroise Croizat à Vault-en-Velin. 
    
## Nettoyage des données 

Importation des données

```{r}
#Librairies nécéssaires
require(readxl)
require(dplyr)
require(stringr)

#Moyenne section 2015/2016
mathsJetons_2015_2016 <- read_excel("../MathsJetons_2015-2016.xlsx") %>% data.frame(row.names = 2)
don1516 <- mathsJetons_2015_2016[mathsJetons_2015_2016$Niveau == "MSM",]

#Moyenne section 2016/2017
mathsJetons_2016_2017 <- read_excel("../MathsJetons_2016-2017.xlsx",sheet = "QualiSsAtyp")
mathsJetons_2016_2017 <- mathsJetons_2016_2017[is.na(mathsJetons_2016_2017[,2]) == FALSE,] %>% data.frame(row.names = 2)
don1617 <- mathsJetons_2016_2017[mathsJetons_2016_2017$Niveau == "MSM",]

#Moyenne section 2017/2018
mathsJetons_2017_2018 <- read_excel("../MathsJetons_2017-2018.xlsx") %>% data.frame(row.names = 2)
don1718<-mathsJetons_2017_2018[mathsJetons_2017_2018$Niveau == "MSM",]
```

Changement de nom des colonnes (pas identique sur don1516 et les autres)

```{r}
colnames(don1516)[c(1,9,13,46,47,48)] <- c("Experimentateur","Lateralite","age","T111.TOTAL","T112.TOTAL","T113.TOTAL")
colnames(don1617)[c(1,9,13,46,47,48)] <- c("Experimentateur","Lateralite","age","T111.TOTAL","T112.TOTAL","T113.TOTAL")
colnames(don1718)[c(1,9,13,46,47,48)] <- c("Experimentateur","Lateralite","age","T111.TOTAL","T112.TOTAL","T113.TOTAL")
```

Ensemble des moyennes sections 2015/2016/2017/2018

```{r}
dataMoySec<-cbind(rbind(don1516,don1617,don1718),c(rep("15/16",length(don1516[,1])),rep("16/17",length(don1617[,1])),rep("17/18",length(don1718[,1]))))
colnames(dataMoySec)[49]<-"annee.scolaire"
```

Recherche des variables à une seule modalité

```{r}

NbMod<-function(x){
  return(length(table(x)))
}
pos1<-which(apply(X=dataMoySec,MARGIN=2,FUN=NbMod)==1)

#Suppression des variables qui n'ont qu'une modalité et ne servent à rien ("Ecole" et "Niveau")
dataPropre<-dataMoySec[,-pos1]

TabMod<-function(x){
  return(table(x))
}

apply(X=dataPropre,MARGIN=2,FUN=TabMod)
```

Correction des modalités de la variable **Type.de.classe** et **Langues**

```{r}
dataPropre$Type.de.classe<-str_to_lower(dataPropre$Type.de.classe)
dataPropre$Type.de.classe<-sub("grands","grand",dataPropre$Type.de.classe)
dataPropre$Type.de.classe<-sub("grand","grands",dataPropre$Type.de.classe)

dataPropre$Langues<-str_to_lower(dataPropre$Langues)
dataPropre$Langues<-sub("/","et",dataPropre$Langues)

#Suppression des variables T11 et T9
dataPropre<-dataPropre[,-c(42:46)]
```

Stats univariées sur le jeu de données (table)
```{r}
apply(X=dataPropre,MARGIN=2,FUN=TabMod)
```

Changement des types de variables

```{r}
#Changement des variables en facteurs
nom<-c("Experimentateur","Pédagogie","Classe","Type.de.classe",
       "Sexe..F.ou.M.","Langues","Lateralite",
       "Classe.d.age",
       "T21.TOTAL","T22.TOTAL","T23.TOTAL","T31TOTAL","T32.TOTAL",
       "T41a.TOTAL","T41b.TOTAL","T41cTOTAL","T41d.TOTAL","T42a.TOTAL",
       "T42b.TOTAL","T42c.TOTAL","T42d.TOTAL","T51.TOTAL","T52.TOTAL","T61.TOTAL",
       "T62TOTAL","T71.TOTAL","T72TOTAL","T81.TOTAL","T82.TOTAL","T83.TOTAL","T84.TOTAL",
       "T85.TOTAL","T86.TOTAL","T87.TOTAL","T88.TOTAL","T89.TOTAL","annee.scolaire")


for (i in 1:ncol(dataPropre)){
  if (colnames(dataPropre)[i]%in%nom ){
    dataPropre[,i]<-as.factor(dataPropre[,i])
  }
}

#Question 1 comme variable numérique
dataPropre$T1.Réponse<-as.numeric(dataPropre$T1.Réponse)
```

Re-stats univariées sur datapropre

```{r}
summary(dataPropre)
```

Mettre en forme le dataframe

```{r}
#Remplacement du nom de la variable "Type.de.classe" par "type.de.classe"
names(dataPropre)[which(names(dataPropre)=="Type.de.classe")]<-"type.de.classe"

#On remplace les na des questions par "0"
posQ<-which(substr(names(dataPropre),1,1)=="T")
questions<-dataPropre[,posQ]
questions[is.na(questions)]<-"0"

#Vérification qu'il n'y ait pas l'incohérence 0 -> 1 (sauf pour les Q4)
vecAnte<-t(apply(questions[,c(2:28)],1,as.numeric))
colnames(vecAnte)<-names(questions[,c(2:28)])
vecPost<-t(apply(questions[,c(3:29)],1,as.numeric))
colnames(vecPost)<-names(questions[,c(3:29)])
vecDiff<-vecPost-vecAnte

#Il existe des incohérences, on les recherche
#On enlève d'abord les questions qui ne peuvent pas avoir d'incohérence
incoher<-vecDiff[,which(as.numeric(substr(names(questions[,3:29]),3,3))>1 & as.numeric(substr(names(questions[,3:29]),2,2))!=4 & as.numeric(substr(names(questions[,3:29]),2,2))!=8)]

#On récupère ensuite les lignes et colonnes comprtant 1 à la diff entre post et ante
incoher2<-incoher[which(apply(incoher,1,max)==1),which(apply(incoher,2,max)==1)]

#Remplacement des questions avec NA par questions avec 0 dans datapropre
dataPropre[,posQ]<-questions

#Correction de la question 2 (enfants 0->1 devient 1->1)
dataPropre$T21.TOTAL[which(dataPropre$T21.TOTAL=="0" & dataPropre$T22.TOTAL=="1")]<-"1"
```

Création du jeu de données où les résultats des questions sont des vecteurs

```{r}

T1<-questions[,1]
T2<-paste(questions[,2],questions[,3],questions[,4],sep="")
T3<-paste(questions[,5],questions[,6],sep="")
T41<-paste(questions[,7],questions[,8],questions[,9],questions[,10],sep="")
T42<-paste(questions[,11],questions[,12],questions[,13],questions[,14],sep="")
T5<-paste(questions[,15],questions[,16],sep="")
questionsVec<-cbind(T1,T2,T3,T41,T42,T5,questions[,17:29])
dataVec<-cbind(dataPropre[,-posQ],questionsVec)
```

Création du jeu de données où les résultats des question sont des sommes

```{r}
questionsNum<-apply(questions,2,as.numeric)
T1<-questionsNum[,1]
T2<-questionsNum[,2]+questionsNum[,3]+questionsNum[,4]
T3<-questionsNum[,5]+questionsNum[,6]
T41<-paste(questions[,7],questions[,8],questions[,9],questions[,10],sep="")
T42<-paste(questions[,11],questions[,12],questions[,13],questions[,14],sep="")
T5<-questionsNum[,15]+questionsNum[,16]
questionsSum<-data.frame(T1,T2,T3,T41,T42,T5,questionsNum[,17:29])
dataSum<-cbind(dataPropre[,-posQ],questionsSum)
```


Changement du nom des colonnes qui ne sont pas très propres

```{r}
names(dataPropre)[c(2,4,5,8,9:13,42)]<-c(
  "Pedagogie",
  "TypeClasse",
  "Sexe",
  "DateNaissance",
  "DateEval",
  "AgeChar",
  "AgeNum",
  "AgeInt",
  "T1",
  "AnneeScolaire"
)

names(dataVec)[c(2,4,5,8,9:13)]<-c(
  "Pedagogie",
  "TypeClasse",
  "Sexe",
  "DateNaissance",
  "DateEval",
  "AgeChar",
  "AgeNum",
  "AgeInt",
  "AnneeScolaire"
)

names(dataSum)[c(2,4,5,8,9:13)]<-c(
  "Pedagogie",
  "TypeClasse",
  "Sexe",
  "DateNaissance",
  "DateEval",
  "AgeChar",
  "AgeNum",
  "AgeInt",
  "AnneeScolaire"
)

#Suppression ". TOTAL"
names(dataPropre)<-sub(".","",names(dataPropre),fixed=TRUE)
names(dataPropre)<-sub("TOTAL","",names(dataPropre),fixed=TRUE)
names(dataPropre)<-sub("Total","",names(dataPropre),fixed=TRUE)
names(dataVec)<-sub(".","",names(dataVec),fixed=TRUE)
names(dataVec)<-sub("TOTAL","",names(dataVec),fixed=TRUE)
names(dataSum)<-sub(".","",names(dataSum),fixed=TRUE)
names(dataSum)<-sub("TOTAL","",names(dataSum),fixed=TRUE)
```


Regroupement des quesions

```{r}
#Regroupement des quesions T8.123 et T8.456789 dans le jeu dataVec
cols.123<-c(names(dataVec[,24:26]))
cols.456789<-c(names(dataVec[,27:32]))
T8.123<-apply(dataVec[,cols.123],1, paste , collapse = "" )
T8.456789<-apply(dataVec[,cols.456789],1, paste , collapse = " " )
dataVec<-cbind(dataVec, T8.123, T8.456789)
dataVec <- dataVec[,!(names(dataVec) %in% c(cols.123,cols.456789 )) ]

#Regroupement des quesions T8.123 et T8.456789 dans le jeu dataSum
T8.123<-dataSum[,"T81"]+dataSum[,"T82"]+dataSum[,"T83"]
T8.456789<-dataSum[,"T84"]+dataSum[,"T85"]+dataSum[,"T86"]+dataSum[,"T87"]+dataSum[,"T88"]+dataSum[,"T89"]
dataSum<-cbind(dataSum, T8.123, "T8.456789"=T8.456789)
dataSum<-dataSum[,!(names(dataSum) %in% c(cols.123,cols.456789 )) ]

```


###	Présence de NAs ...
## Ajustement des variables
# Analyse exploratoire
##	Univariée
##	Multivariée
##	Recherche de regroupement de variables (cah sur les variables)
# Recherche de différence significative entre p1 et p2
##	Regression logistique 
##	Tests sur les différentes réponses

Creation of dataframes containing only respectively P1 and P2 
```{r}
dataPropreP1<-subset(dataPropre, Pedagogie == "P1")
dataPropreP2<-subset(dataPropre, Pedagogie == "P2")
```

```{r}
# T1 t-test
tt<-t.test(dataPropreP1$T1, dataPropreP2$T1)

# the rest - proportion tests
d=data.frame(x=rep(0,27))
for (i in 14:41){
  mat.i<-cbind(matrix(table(dataPropreP1[,i])), matrix(table(dataPropreP2[,i])))
  prop.i<-prop.test(mat.i, alternative = "two.sided", correct = FALSE)
  d[i,] = prop.i$p.value
}

d<-data.frame(d[-c(1:13),])
row.names(d)<-colnames(dataPropre[,14:41])
colnames(d)<-c("p-values of prop.test")
d[29,]=tt$p.value
rownames(d)[29]<-"T1"

### Final result of p-values (two.sided) ###
print(d)

# rows where p-value is smaller than 0.05
subset(d, d[,1] < 0.05)
```

Trying with less option
```{r}
d=data.frame(x=rep(0,27))
for (i in 14:41){
  mat.i<-cbind(matrix(table(dataPropreP1[,i])), matrix(table(dataPropreP2[,i])))
  prop.i<-prop.test(mat.i, alternative = "less", correct = FALSE)
  d[i,] = prop.i$p.value
}

d<-data.frame(d[-c(1:13),])
row.names(d)<-colnames(dataPropre[,14:41])
colnames(d)<-c("p-values of prop.test")
d[29,]=t.test(dataPropreP1$T1, dataPropreP2$T1)$p.value
rownames(d)[29]<-"T1"

### Final result of p-values (less) ###
subset(d, d[,1] < 0.05) 
```

No new results

Trying with greater option

```{r}
d=data.frame(x=rep(0,27))
for (i in 14:41){
  mat.i<-cbind(matrix(table(dataPropreP1[,i])), matrix(table(dataPropreP2[,i])))
  prop.i<-prop.test(mat.i, alternative = "greater", correct = FALSE)
  d[i,] = prop.i$p.value
}

d<-data.frame(d[-c(1:13),])
row.names(d)<-colnames(dataPropre[,14:41])
colnames(d)<-c("p-values of prop.test")
d[29,]=t.test(dataPropreP1$T1, dataPropreP2$T1)$p.value
rownames(d)[29]<-"T1"

### Final result of p-values (greater) ###
subset(d, d[,1] < 0.05) 
```
ONLY T81 added

Testing with new variables (two.sided)

```{r}
load("../.RData")
don.groupeP1<-subset(don.groupe, Pedagogie == "P1")
don.groupeP2<-subset(don.groupe, Pedagogie == "P2")

m<-cbind(matrix(table(don.groupeP1[,2])), matrix(table(don.groupeP2[,2])))
pt<-prop.test(m, alternative = "two.sided", correct = FALSE)
df1 = pt$p.value
tt<-t.test(don.groupeP1$audela, don.groupeP2$audela)
df2  = tt$p.value
tt<-t.test(don.groupeP1$outils, don.groupeP2$outils)
df3 = tt$p.value
tt<-t.test(don.groupeP1$objet, don.groupeP2$objet)
df4  = tt$p.value

df=data.frame(x=rep(0,4))
df[1,]=df1
df[2,]=df2
df[3,]=df3
df[4,]=df4

colnames(df)<-c("p-values/prop.test - New Variables")
row.names(df)<-colnames(don.groupe[,2:5])
df
```

Testing with greater option

```{r}
m<-cbind(matrix(table(don.groupeP1[,2])), matrix(table(don.groupeP2[,2])))
pt<-prop.test(m, alternative = "greater", correct = FALSE)
df1 = pt$p.value
tt<-t.test(don.groupeP1$audela, don.groupeP2$audela, alternative = "greater")
df2  = tt$p.value
tt<-t.test(don.groupeP1$outils, don.groupeP2$outils, alternative = "greater")
df3 = tt$p.value
tt<-t.test(don.groupeP1$objet, don.groupeP2$objet, alternative = "greater")
df4  = tt$p.value

df=data.frame(prop.i=rep(0,4))
df[1,]=df1
df[2,]=df2
df[3,]=df3
df[4,]=df4

colnames(df)<-c("p-values/prop.test - New Variables")
row.names(df)<-colnames(don.groupe[,2:5])
df
```

Testing with less option

```{r}
m<-cbind(matrix(table(don.groupeP1[,2])), matrix(table(don.groupeP2[,2])))
pt<-prop.test(m, alternative = "less", correct = FALSE)
df1 = pt$p.value
tt<-t.test(don.groupeP1$audela, don.groupeP2$audela, alternative = "less")
df2  = tt$p.value
tt<-t.test(don.groupeP1$outils, don.groupeP2$outils, alternative = "less")
df3 = tt$p.value
tt<-t.test(don.groupeP1$objet, don.groupeP2$objet, alternative = "less")
df4  = tt$p.value

df=data.frame(prop.i=rep(0,4))
df[1,]=df1
df[2,]=df2
df[3,]=df3
df[4,]=df4

colnames(df)<-c("p-values/prop.test - New Variables")
row.names(df)<-colnames(don.groupe[,2:5])
df
```

Visualisation of significantly different data

```{r}
# T72
T72 <- rbind(prop.table(table(dataPropreP1$T72)),prop.table(table(dataPropreP2$T72)))
barplot(T72, beside = T, col = c("blue", "green"), main="T72 reponses: P1>P2",
        legend.text =c("P1","P2"),args.legend = list(x = "topright"))

# T81
T81 <- rbind(prop.table(table(dataPropreP1$T81)),prop.table(table(dataPropreP2$T81)))
barplot(T81, beside = T, col = c("blue", "green"), main="T81 reponses: P1<P2",
        legend.text =c("P1","P2"),args.legend = list(x = "top"))

# T87
T87 <- rbind(prop.table(table(dataPropreP1$T87)),prop.table(table(dataPropreP2$T87)))
barplot(T87, beside = T, col = c("blue", "green"), main="T87 reponses: P1<P2",
        legend.text =c("P1","P2"),args.legend = list(x = "top"))

# T88
T88 <- rbind(prop.table(table(dataPropreP1$T88)),prop.table(table(dataPropreP2$T88)))
barplot(T88, beside = T, col = c("blue", "green"), main="T88 reponses: P1<P2",
        legend.text =c("P1","P2"),args.legend = list(x = "top"))

# T89
T89 <- rbind(prop.table(table(dataPropreP1$T89)),prop.table(table(dataPropreP2$T89)))
barplot(T89, beside = T, col = c("blue", "green"), main="T89 reponses: P1<P2",
        legend.text =c("P1","P2"),args.legend = list(x = "top"))

# audela
audela <- rbind(prop.table(table(don.groupeP1$audela)),prop.table(table(don.groupeP2$audela)))
barplot(audela, beside = T, col = c("blue", "green"), main="audela: P1<P2",
        legend.text =c("P1","P2"),args.legend = list(x = "topright"))
```




##	Arbre de regression ?
# Conclusion
	
	


